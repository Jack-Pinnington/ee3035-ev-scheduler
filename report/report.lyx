#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass paper
\use_default_options true
\begin_modules
todonotes
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command biber
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine biblatex
\cite_engine_type authoryear
\biblio_style plain
\biblatex_bibstyle ieee
\biblatex_citestyle ieee
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Cloud Back-End
\end_layout

\begin_layout List of TODOs

\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
In the front-end/back-end model the purpose of a back-end is to act as the
 data access layer (DAL) for a service.
 Comparing this with the client-server model the front-end is typically
 the client with the server acting as the back-end.
\end_layout

\begin_layout Section
Language
\end_layout

\begin_layout Standard
There are many languages well suited to writing HTTP servers from well establish
ed ecosystems like PHP, Java and Ruby to newer environments such as Python
 and Javascript with Node.
 An understanding of the language combined with high speed of prototyping
 led Python to be chosen.
 
\end_layout

\begin_layout Standard
Libraries for creating HTTP applications in Python typically implement the
 Web Server Gateway Interface (WSGI), an interface for passing web requests
 from the web server which hosts the application to the application itself.
 This theoretically allows any WSGI server to run any application written
 using a WSGI framework.
\end_layout

\begin_layout Standard
Two of the most popular frameworks are Flask
\begin_inset CommandInset citation
LatexCommand cite
key "flask"
literal "false"

\end_inset

 and Django
\begin_inset CommandInset citation
LatexCommand cite
key "django"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Django has a strong database abstraction layer and is opinionated in the
 structure of a web application.
 Flask however has a more minimalist structure, functioning as a micro-framework
 that lightly wraps around both the Werkzeug library for a WSGI toolkit
 and Jinja for template engine support.
 It has no database layer or form validation, however it's un-opinionated
 structure and flexibility proves to be agile and very powerful.
 Flask was chosen to write the application.
 
\end_layout

\begin_layout Section
Infrastructure
\end_layout

\begin_layout Standard
Google Cloud Platform
\begin_inset CommandInset citation
LatexCommand cite
key "gcp"
literal "false"

\end_inset

 (GCP) is a platform of cloud computing products from Google offering services
 including compute, storage, databases, networking, AI and IOT.
 Built upon the same infrastructure that hosts the public facing Google
 services, GCP is one of the largest and most feature rich platforms of
 it's type operating in the same space as Amazon Web Services and Microsoft's
 Azure platform.
\end_layout

\begin_layout Standard
With effective documentation and compelling free quotas combined with previous
 experience with the platform, GCP was used to provide all the hosting needs
 for the project without incurring any costs.
\end_layout

\begin_layout Subsection
HTTP API Hosting
\end_layout

\begin_layout Standard
The Flask HTTP server requires hosting in order to allow communications
 between the server and both the app and hardware over the public internet.
 This can be done in various ways, one of which being to create a virtual
 machine on which WSGI applications can be started using a WSGI server like
 Gunicorn.
 While this presents the most manual set-up requiring careful Linux administrati
on to create a secure public facing server, the growth of cloud computing
 platforms has removed the requirement for such overhead.
 
\end_layout

\begin_layout Subsubsection
Serverless and PaaS
\end_layout

\begin_layout Standard
Serverless computing describes a new type of cloud service architecture
 that abstracts away much of the required administration, aiming to make
 the user experience feel 
\begin_inset Quotes eld
\end_inset

serverless
\begin_inset Quotes erd
\end_inset

.
 There are many different services using implementations the architecture
 with the most popular being function-as-a-service or FaaS, the AWS and
 GCP products being Lambda functions and Cloud functions respectively.
 FaaS services allow users to write and deploy individual functions or methods
 of source code to be run by a trigger, functions are charged for per invocation.
 These triggers can be HTTP requests allowing single functions to be mounted
 on unique URLs, database state changes and asynchronous message queues.
 HTTP triggers allow users to write individual API endpoints as functions
 however for this project's requirements this would be too granular, FaaS
 services instead proved useful for utility functions for the service.
\end_layout

\begin_layout Standard
Platform as a service or PaaS is a similar architecture retaining many of
 the advantages of serverless products.
 It finds a compromise between virtual machine management and FaaS options
 of before.
 When thinking about serverless as a concept as opposed to the implementations
 themselves, FaaS provides serverless hosting for individual methods of
 source code, PaaS can be seen as serverless hosting of entire WSGI applications
 when working in Python.
 In this way advantages of serverless hosting such as reduced configuration
 and high scalability are retained while allowing developers to create APIs
 with WSGI applications as opposed to individual method or functions per
 endpoint.
\end_layout

\begin_layout Standard
One of the main advantages of both serverless and PaaS architecture is it's
 ability to horizontally scale on demand.
 Horizontal scaling describes a services ability to handle concurrent traffic,
 typically scaling horizontally is achieved by running more instances of
 an application at a time.
 This is as opposed to vertical scaling which instead describes a services
 ability to handle more traffic with the same resources, typically by making
 each instance faster.
\end_layout

\begin_layout Subsubsection
Google App Engine
\end_layout

\begin_layout Standard
Google App Engine (GAE) is a PaaS product on GCP providing application hosting
 for many different languages including Python.
 GAE provides many powerful features that either require complex configuration
 or are unfeasible with bare-metal solutions.
\end_layout

\begin_layout Standard
For example GAE provides automatic scaling allowing the number of application
 instances to dynamically increase in response to increased traffic.
 The scope of the GCP infrastructure gives effectively unlimited horizontal
 scale to smaller services that would otherwise be unable to handle such
 demand.
\end_layout

\begin_layout Standard
GAE also makes using TLS security extremely easy.
 With a manual hosting set-up, TLS security can be included by attaching
 a certificate to the hosting web server, either purchased from a certificate
 authority such as Verisign or for free generated by Let's Encrypt.
 It is also advisable to include a rule within the web server in order to
 redirect unencrypted HTTP traffic on port 80 to encrypted HTTPS traffic
 on port 443.
\end_layout

\begin_layout Standard
App Engine includes TLS security with a Let's Encrypt certificate as standard
 and within the deployment configuration automatic redirects from HTTP to
 HTTPS can be added with one line.
 These two features make development and deployment fast and secure.
\end_layout

\begin_layout Subsection
Database
\end_layout

\begin_layout Standard
GCP has many options for database services depending on the requirements.
 For both SQL and NoSQL, GCP has databases designed to operate at different
 scales and with different features.
 For example, Cloud SQL offers managed MySQL, PostgreSQL and SQL server
 instances with ultra low latency for smaller scale use but Cloud Spanner
 offers scalable SQL instances designed to be highly consistent at a global
 scale.
 
\end_layout

\begin_layout Standard
Equally, for NoSQL there are two main options.
 Cloud Bigtable offers global scale NoSQL database instances able to handle
 petabyte sized datasets designed for analytical big data workloads.
 The other option is Cloud Firestore, a new service from GCP under the Firebase
 brand banner.
 
\end_layout

\begin_layout Standard
Firestore is also rated for global use and has a few key features that made
 it the ideal database for this project.
 First, being marketed as the flagship NoSQL product, Firestore has key
 integrations with the rest of the GCP services, for example Cloud Functions
 can be triggered directly by changes within the database and Firebase provides
 authenticated access to the data from within mobile applications.
\end_layout

\begin_layout Standard
Firestore is also highly scalable and consistent as a result of it's serverless
 architecture.
 For these reasons Firestore was chosen to host the application data for
 this service.
\end_layout

\begin_layout Subsection
Mobile Notifications
\end_layout

\begin_layout Subsection
Scheduling
\end_layout

\begin_layout Subsection
Cloud Pub/Sub
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename cloud-structure.png
	lyxscale 30
	width 80col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Architecture of Google Cloud Platform services
\begin_inset CommandInset label
LatexCommand label
name "fig:gcp-services"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Data Model
\end_layout

\begin_layout Standard
In designing the data model for this project objects were defined for users
 and the charging structure, a UML diagram for the architecture can be seen
 in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:class-diagram"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename class diagram.png
	lyxscale 30
	width 80col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Class diagram for data model
\begin_inset CommandInset label
LatexCommand label
name "fig:class-diagram"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
User
\end_layout

\begin_layout Standard
Users have associated usernames and passwords for identification and authenticat
ion.
 Usernames are the primary key differentiating objects and are case insensitive.
 Passwords are salted and hashed using the Werkzeug security functionality,
 for more information see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Passwords"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
The user type allowed the implementation of access controls between different
 use cases.
 End users are classed as 'user' and have limited access to much of the
 resource types while 'admin' accounts are able to write changes make all
 types of requests and this set of user types would be heavily restricted.
 Service accounts are used by the charging units in order to make changes
 on behalf of the system.
 This includes changing the state of the charging structure throughout the
 life cycle of a charging session, end-users cannot make any changes of
 this sort.
\end_layout

\begin_layout Standard
The state of the user is defined by the life cycle of a charging session
 as described in the associated enumerated type.
 Using Python properties specific state changes for a user have associated
 actions, this is where mobile notifications are triggered in order to inform
 the user of changes in the charging state.
\end_layout

\begin_layout Standard
Users have an access token field and associated last updated time in order
 to secure the HTTP API, the authentication methods used are covered in
 section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Authentication"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
The score and it's associated time of last update are used by the queue
 system in order to determine priorities when selecting users for sessions.
 The score is a function of time since it's last update and the users actions
 in that time using update_score(), the score algorithm is covered in section
 
\color red
[SECTION WHERE JACK TALKS ABOUT ALGORITHM]
\color inherit
.
 The time parameter for this function is accepted as the time of the scores
 update when persisting this to the database.
 This is to account for the difference in time when processing many users
 in succession.
\end_layout

\begin_layout Standard
Check_password() takes a clear-text password string as input and returns
 a boolean value determining whether it is the same as the stored password.
 This works by salting and hashing the password in the same fashion as the
 initial password was when supplied by the user.
 The hashes are compared for equality which also indicates that the two
 have the same clear-text values.
\end_layout

\begin_layout Subsection
Charging Structure
\end_layout

\begin_layout Standard
The layout for charging architecture defines two object modelling physical
 structure and a session object.
 A Location defines a physical location at which are charging stations.
 An office building with electric vehicle parking spaces is a Location as
 would be a multi-story car park.
 Functionally it is any group of charging spots.
\end_layout

\begin_layout Standard
A Charger is an individual charging station which will have an associated
 charging unit to relay session information.
 
\end_layout

\begin_layout Standard
A Session defines a discrete charging window completed by a user.
 It begins when the queue starts a session for a user who is informed as
 such.
 The user begins charging their car and upon completion is notified that
 they can remove their car.
 When a user unplugs the car the session ends and ticks the locations queue
 to select the next user.
\end_layout

\begin_layout Subsubsection
Location
\end_layout

\begin_layout Standard
A Location has a location_id to act as the primary key, they are case insensitiv
e.
 A location has a list of contained chargers and a list of users representing
 the queue waiting to charge.
 The tick_queue() function updates the score for each user in the queue
 and selects the lowest scoring to receive the next session if available.
 The queue is tick both when a user is added to the queue and when a session
 ends to ensure the time is used effectively.
\end_layout

\begin_layout Subsubsection
Charger
\end_layout

\begin_layout Standard
A Charger's associated charger_id differentiates chargers of a location,
 they are unique to that location's namespace.
 The active session field is for the integer session_id of the currently
 running session if one is available.
 A null value indicates no session is running.
 The state field functions similarly to the same for the User object and
 defines the charger's position within the life cycle of a session.
\end_layout

\begin_layout Subsubsection
Session
\end_layout

\begin_layout Standard
Sessions are retained after their end for logging purposes, integer session
 IDs were selected in order to allow easier retrieval of new IDs, the maximum
 value of all available IDs is incremented.
 Similarly to the charger key session IDs are unique within their charger's
 namespace, this allows a single session to be identified by a fully qualified
 ID, separated by colons for example,
\end_layout

\begin_layout Quote
location1:charger1:5
\end_layout

\begin_layout Standard
Due to the use of IDs in request URLs and the fully qualified ID, colons,
 spaces and forward slashes are illegal characters for all three IDs.
 Sessions have date-time objects for both their start and end time and a
 reference to the User object who owns the session.
\end_layout

\begin_layout Section
Flask Server
\end_layout

\begin_layout Standard
Flask
\begin_inset CommandInset citation
LatexCommand cite
key "flask"
literal "false"

\end_inset

 is a lean Python web framework that provides flexibility and extensibility
 for web server development.
 The framework is used by instantiating a Flask application and registering
 routes with the app object.
\end_layout

\begin_layout Standard
Routes are registered using a function decorator provided by the application
 defining that method as a URL route.
 The return value of the method is passed back to the HTTP requester as
 the response.
 This decorator takes both the intended route string and the available HTTP
 methods as parameters.
\end_layout

\begin_layout Subsection
RESTful Services
\end_layout

\begin_layout Standard
In designing the web server an approach taking in to account REST architecture.
 REST or Representational State Transfer is a structure and ethos for designing
 web services.
 Each URL is treated as an identifier for a resource it describes.
 Making requests with different HTTP methods at this URL represents different
 action to be taken on the object that URL identifies.
 The most common methods are GET, POST, PUT and DELETE.
\end_layout

\begin_layout Standard
GET is typically used as a read only method who's result is a text serialization
 of the object.
\end_layout

\begin_layout Standard
The POST method is used to create an object while PUT is used to replace
 the object.
 For this API PUT is used to replace individual fields of some objects making
 the definition of PUT closer to update.
\end_layout

\begin_layout Standard
DELETE is for deleting the object the URL denotes.
\end_layout

\begin_layout Standard
The aim of a RESTful web service is to make interacting with APIs consistent
 and intuitive both as a whole and when comparing different APIs.
 It is similar to a design pattern.
\end_layout

\begin_layout Subsection
Blueprints
\end_layout

\begin_layout Standard
A useful tool for encapsulating discrete parts of a Flask API that should
 still be part of a single application is to use blueprints.
\end_layout

\begin_layout Standard
Blueprints group a set of routes allowing them to be mounted on a Flask
 application object together.
 Blueprints have routes registered in a similar fashion as the Flask application
, blueprints are then individually hung off of a prefix URL string by the
 application following instantiation.
\end_layout

\begin_layout Standard
Blueprints were used to separate routes for authentication, users and the
 charging structure in order to closely follow the data model, a visualisation
 of the final URL route map can be seen in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:api-route-map"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename api-map.png
	lyxscale 30
	width 70col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Visualisation of API endpoints with example fully qualified route
\begin_inset CommandInset label
LatexCommand label
name "fig:api-route-map"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Charging Structure Blueprint
\end_layout

\begin_layout Subsubsection
Location
\end_layout

\begin_layout Standard
Making a GET request at the /api/location endpoint responds with a list
 of all of the available locations registered in the service.
 Due to the security implications of having this information available,
 only admin accounts can make this request.
\end_layout

\begin_layout Standard
Following the location with a location ID in the form /api/location/<location_id
> allows requests to be made about individual locations.
 GET requests retrieve information about the location including the registered
 chargers and the current queue.
\end_layout

\begin_layout Standard
PUT and POST requests manipulate and create locations respectively.
 Currently, however, there are no changes that can be made to a location
 using the PUT method.
 The DELETE method deletes a location, all of the PUT, POST and DELETE methods
 require admin rights.
\end_layout

\begin_layout Subsubsection
Queue
\end_layout

\begin_layout Standard
The queue endpoint for a location allows the addition and removal of users
 from a queue at a location.
 The POST method adds the currently logged in user, as inferred from the
 authentication credentials, to the queue at that location, The DELETE method
 removes the same user from the queue.
\end_layout

\begin_layout Subsubsection
Charger
\end_layout

\begin_layout Standard
The /api/location/<location_id>/charger allows GET requests in order to
 retrieve the list of registered chargers at that location.
 Similar to the location endpoint this can then be sub-indexed by charger
 ID in the following fashion
\end_layout

\begin_layout Quote
/api/location/<location_id>/charger/<charger_id>
\end_layout

\begin_layout Standard
and has the same implementations of HTTP methods.
 Unlike the location endpoint the charger allows updates to be made to it's
 state using the PUT method.
 This is a critical part of the session life cycle and is a change received
 by the charging units to indicate that charging has started or stopped.
 The new state is entered as part of the JSON body of the request.
 It is worth noting that charging sessions are not started or stopped by
 making the associated state changes but instead via the session endpoint.
 State changes in this fashion are instead for intra-session changes.
 Similar to the location endpoint, write functions must be made by admin
 accounts.
\end_layout

\begin_layout Subsubsection
Session
\end_layout

\begin_layout Standard
The session endpoint is for manipulating the charger session at a specific
 charger.
 The GET request retrieves the JSON representation of the session including
 start time and associated user.
 While the PUT request is supported, there are no changes that can be made
 to a session via it's endpoint.
 The POST method, instead of starting sessions, queues the user at that
 location instead.
 This is in order to stop users jumping the queue by directly starting sessions
 at the charger.
\end_layout

\begin_layout Standard
The DELETE method is for ending sessions and is again particularly used
 by the charging units in order to end sessions when the car is unplugged.
\end_layout

\begin_layout Subsection
User Blueprint
\end_layout

\begin_layout Standard
The user blueprint only has one endpoint, /api/user.
 For each allowed HTTP method the actionable user is inferred from the authentic
ation credentials.
 The mobile application makes system requests on behalf of the user which
 is typically where most of the user actions will originate from.
\end_layout

\begin_layout Standard
Not all actions need to be made on the calling user however, admin accounts
 are able to override the target user by including a username in the URL
 arguments, for example 
\end_layout

\begin_layout Quote
/api/user?username=andy
\end_layout

\begin_layout Standard
The GET method for users returns the username, state and type of the requested
 user.
 The PUT allows updates to be made to the user password.
 POST and DELETE allow the creation and deletion of users however the requesting
 user must be an admin.
\end_layout

\begin_layout Subsection
Authentication Blueprint
\end_layout

\begin_layout Section
Security
\end_layout

\begin_layout Subsection
Passwords
\begin_inset CommandInset label
LatexCommand label
name "subsec:Passwords"

\end_inset


\end_layout

\begin_layout Standard
Passwords should never be kept in the form they are provided by users at
 rest as any breaches of the database will expose valuable user information.
 Instead, passwords undergo processes called salting and hashing.
 Hashing is a one way function that takes a variable length string and produces
 a fixed length output, the same input string always provides the same output
 string.
 Importantly for password storage is the one way characteristic of the function
 meaning the hashed password cannot be inversely 
\begin_inset Quotes eld
\end_inset

un-hashed
\begin_inset Quotes erd
\end_inset

 back into the clear text string.
 Cracking hashed passwords must instead be done with large lookup tables
 of passwords and the associated precomputed hashes, known as a rainbow
 table attack.
 In order to protect against brute force attacks of this fashion, salts
 are used.
 A salt is a random string of data that is appended to the user password
 before hashing and then stored with it.
 This reduces the effectiveness of a rainbow table attack as rainbow tables
 cannot be practically pre-calculated for input passwords when a random
 string has been added.
 Passwords are salted using a 8 character long salt before being hashed
 using the pbkdf2:sha256 algorithm.
\end_layout

\begin_layout Subsection
Authentication
\begin_inset CommandInset label
LatexCommand label
name "sec:Authentication"

\end_inset


\end_layout

\begin_layout Standard
Authentication is a crucial concern when designing web services.
 Access controls and security measures are important facets of a system
 however they are useless if weak authentication allows them to be circumvented.
 There are many ways to secure a HTTP API that range in security and complexity,
 finding a balance for the context of the service is important.
\end_layout

\begin_layout Standard
Most methods of authentication eventually authenticate each request using
 a HTTP header with the 
\begin_inset Quotes eld
\end_inset

Authorization
\begin_inset Quotes erd
\end_inset

 header key of key-value pairs.
 The value of this header prescribes which method is being used.
\end_layout

\begin_layout Subsubsection
Basic Auth
\end_layout

\begin_layout Standard
One of the most basic methods for authenticating with a HTTP is named as
 such, basic access authentication.
 Basic auth sends the username and password for a user within the authorization
 header in the following format,
\end_layout

\begin_layout Quote
Basic base64_encode(<username>:<password>)
\end_layout

\begin_layout Standard
Base64 encoding is a binary-to-text encoding method and is not a form of
 encryption or hashing, any agent with the content of the request can trivially
 get access to the cleartext user credentials.
 
\end_layout

\begin_layout Standard
When ensuring, as this service does, that all requests of the API are encrypted
 using TLS, then these credentials are secure in transit, however this is
 not the only attack surface which should be protected.
 It also requires the requesting agent to have access to the user's cleartext
 password for inclusion every time which should be minimised as much as
 possible.
 There is inherent risk if each HTTP request includes the unencrypted user
 password and ideally it should occur as little as possible.
 Basic authentication was used during the beta development but eventually
 a more secure method was used for release.
\end_layout

\begin_layout Subsubsection
Bearer Token
\end_layout

\begin_layout Section
Pricing
\end_layout

\begin_layout Standard
An important aspect of using a third-party hosting platform for all the
 required services is the prices for each service, both currently and when
 anticipating future growth.
 When looking back to figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:gcp-services"
plural "false"
caps "false"
noprefix "false"

\end_inset

 each of the listed services have free tiers and prices following these
 quotas.
 Using estimations of possible system loads and the Google Cloud Platform
 pricing calculator
\begin_inset CommandInset citation
LatexCommand cite
key "gcp-pricing"
literal "false"

\end_inset

 an estimation of running costs can be obtained.
\end_layout

\begin_layout Standard
Firestore database allows 1GB of storage for free, a limit that with text
 based records would not be easily reached.
 It also allows 50,000 reads, 20,000 writes and 20,000 deletes a day.
\end_layout

\begin_layout Standard
The serverless Cloud Functions allow 2 million invocations a month for free
 with 400,000 GB-seconds memory, 200,000 GHz-seconds of compute time.
 Being used as a utility function for updating user access tokens means
 that these quotas would likely not be reached.
\end_layout

\begin_layout Standard
The service that is most likely to be used beyond it's free quotas is that
 of the App Engine.
 The App Engine provides 28 instance hours a day, while the service would
 not likely be used during the night busy times of day could see more simultaneo
us traffic to the service and require more running instances.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "references"
options "bibtotoc"

\end_inset


\end_layout

\end_body
\end_document
