#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass paper
\use_default_options true
\begin_modules
todonotes
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command biber
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine biblatex
\cite_engine_type authoryear
\biblio_style plain
\biblatex_bibstyle ieee
\biblatex_citestyle ieee
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout List of TODOs

\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Part
Cloud Services
\end_layout

\begin_layout Standard
When designing a centralised commercial product with services available
 over the internet, the code to run those services cannot solely be run
 in individual phone apps or on IOT-esque pieces of hardware.
 The need for an authoritative store of information such as user details
 and service specific information (location and charge station details)
 requires a central instance of code to store information and make that
 data available when properly authorised.
\end_layout

\begin_layout Standard
The relationship between the code that the user interacts with directly
 including the mobile app and the charging unit and that which centrally
 controls the service is described as the separation between the front-end
 and back-end of an application.
\end_layout

\begin_layout Standard
More precisely in the front-end/back-end model the back-end acts as the
 data access layer (DAL), while the front-end is the presentation layer
 for a service.
 Comparing this with the client-server model the client is typically the
 front-end with the server acting as the back-end.
\end_layout

\begin_layout Standard
To communicate with a server over the internet the Hypertext Transfer Protocol
 (HTTP) is used.
 As such, destination servers host HTTP servers to process and respond to
 received requests.
 At a high level HTTP APIs typically act as a layer of logic between users
 and databases for data persistence.
\end_layout

\begin_layout Section
Language
\end_layout

\begin_layout Standard
There are many languages well suited to writing HTTP servers from well establish
ed ecosystems like PHP, Java and Ruby to newer environments such as Python
 and Javascript using Node.js.
 An understanding of the language combined with high speed of prototyping
 led Python to be chosen.
 
\end_layout

\begin_layout Standard
Libraries for creating HTTP applications in Python typically implement the
 Web Server Gateway Interface (WSGI), an interface for passing web requests
 from the web server which hosts the application to the application itself.
 This theoretically allows any WSGI server to run any application written
 using a WSGI framework.
\end_layout

\begin_layout Standard
Two of the most popular frameworks are Flask
\begin_inset CommandInset citation
LatexCommand cite
key "flask"
literal "false"

\end_inset

 and Django
\begin_inset CommandInset citation
LatexCommand cite
key "django"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Django has a strong database abstraction layer and is 
\begin_inset Quotes eld
\end_inset

somewhat-opinionated
\begin_inset Quotes erd
\end_inset

 about the structure of web applications.
 Flask however has a more minimalist structure, functioning as a micro-framework
 that lightly wraps around both the Werkzeug library for a WSGI toolkit
 and Jinja for template engine support.
 It has no database layer or form validation, however it's un-opinionated
 structure and flexibility proves to be agile and very powerful.
 For these reasons Flask was chosen for implementing the WSGI interface.
 
\end_layout

\begin_layout Section
Infrastructure
\end_layout

\begin_layout Standard
Google Cloud Platform
\begin_inset CommandInset citation
LatexCommand cite
key "gcp"
literal "false"

\end_inset

 (GCP) is a platform of cloud computing products from Google offering services
 including compute, storage, databases, networking, AI and IOT.
 Built upon the same infrastructure that hosts the public facing Google
 services, GCP is one of the largest and most feature rich platforms of
 it's type operating in the same space as Amazon Web Services and Microsoft's
 Azure platform.
\end_layout

\begin_layout Standard
With effective documentation and compelling free quotas combined with previous
 experience with the platform, GCP was used to provide all the hosting needs
 for the project without incurring any costs.
 A final diagram of the cloud service architecture can be seen in figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:gcp-services"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsection
HTTP API Hosting
\end_layout

\begin_layout Standard
The Flask HTTP server requires hosting in order to allow communications
 between the server and both the mobile app and hardware over the public
 internet.
 This can be done in various ways, one of which being to create a virtual
 machine on which WSGI applications can be started using a WSGI server like
 Gunicorn.
 While this presents the most manual set-up requiring careful Linux administrati
on to create a secure public facing server, the growth of cloud computing
 platforms has removed the requirement for such overhead.
 
\end_layout

\begin_layout Subsubsection
Serverless Architecture
\end_layout

\begin_layout Standard
Serverless computing describes a new type of cloud service architecture
 that abstracts away much of the required administration, aiming to make
 the user experience feel 
\begin_inset Quotes eld
\end_inset

serverless
\begin_inset Quotes erd
\end_inset

.
 There are many different services using implementations the architecture
 with the most popular being function-as-a-service or FaaS, the AWS and
 GCP products being Lambda functions and Cloud functions respectively.
 FaaS services allow users to write and deploy individual functions or methods
 of source code to be run by a trigger, functions are then charged per invocatio
n.
 These triggers can include database state changes, asynchronous message
 queues or HTTP requests providing single functions with unique URLs to
 trigger them.
 HTTP triggers theoretically allow users to write entire APIs with endpoints
 as individual functions.
\end_layout

\begin_layout Subsubsection
PaaS
\end_layout

\begin_layout Standard
Platform as a service or PaaS is a similar architecture retaining many of
 the advantages of serverless products.
 It finds a compromise between the manual approaches of virtual machine
 management and the more abstracted FaaS options of before.
 To compare to FaaS which provides serverless hosting for individual methods
 of source code, PaaS can be seen as serverless hosting of entire WSGI applicati
ons when working in Python.
 In doing so the advantages of serverless hosting such as reduced configuration
 and high scalability are retained while allowing developers to create APIs
 in the more industry standard WSGI format.
\end_layout

\begin_layout Standard
One of the main advantages of serverless (including PaaS) architecture is
 it's ability to horizontally scale on demand.
 Horizontal scaling describes a service's ability to handle concurrent traffic,
 typically scaling horizontally is achieved by running more instances of
 an application concurrently.
 This is in contrast to vertical scaling which instead describes a services
 ability to handle more traffic with the same resources, typically by making
 each instance faster.
\end_layout

\begin_layout Subsubsection
Google App Engine
\end_layout

\begin_layout Standard
Google App Engine (GAE) is a PaaS service by GCP providing application hosting
 for many different languages including Python.
 GAE provides many powerful features that either require complex configuration
 or are unfeasible with bare-metal or virtual machine based solutions.
\end_layout

\begin_layout Standard
For example GAE provides automatic horizontal scaling allowing the number
 of application instances to dynamically increase in response to increased
 traffic.
 The scope of the GCP infrastructure gives effectively unlimited horizontal
 scale to smaller services that would otherwise be unable to handle such
 demand.
\end_layout

\begin_layout Standard
GAE also makes using TLS security extremely easy.
 With a manual hosting set-up, TLS security can be included by attaching
 a certificate to the hosting web server, either purchased from a certificate
 authority such as Verisign or for free generated by Let's Encrypt.
 It is also advisable to include a rule within the web server in order to
 redirect unencrypted HTTP traffic on port 80 to encrypted HTTPS traffic
 on port 443.
\end_layout

\begin_layout Standard
App Engine includes TLS security with a Let's Encrypt certificate as standard
 and within the deployment configuration automatic redirects from HTTP to
 HTTPS can be added with one line.
 These two features can make development and deployment fast and secure.
\end_layout

\begin_layout Subsection
Database
\end_layout

\begin_layout Standard
GCP has many options for database services depending on the requirements.
 For both SQL and NoSQL, GCP has databases designed to operate at different
 scales and with different features.
 For example, Cloud SQL offers managed MySQL, PostgreSQL and SQL server
 instances with ultra low latency for smaller scale use but Cloud Spanner
 offers scalable SQL instances designed to be highly consistent at a global
 scale.
 
\end_layout

\begin_layout Standard
Equally, for NoSQL there are two main options.
 Cloud Bigtable offers global scale NoSQL database instances able to handle
 petabyte sized datasets designed for analytical big data workloads.
 Alternatively, Cloud Firestore is a new service from GCP under the Firebase
 brand banner.
\end_layout

\begin_layout Standard
Being marketed as the flagship NoSQL product, Firestore has key integrations
 with the rest of the GCP services, for example Cloud Functions can be triggered
 directly by changes within the database and Firebase provides authenticated
 access to the data from within mobile applications.
\end_layout

\begin_layout Standard
Firestore is also highly scalable and consistent as a result of it's serverless
 architecture.
\end_layout

\begin_layout Subsection
Mobile Notifications
\end_layout

\begin_layout Standard
Mobile notifications are a useful tool for providing instant messages and
 updates to a user having superseded the previously accepted methods of
 email and SMS messages.
 
\end_layout

\begin_layout Standard
While mobile applications can locally generate notifications, a more useful
 method of using notifications is for them to be generated and delivered
 by a cloud based service and transmitted over the internet.
 This allows changes in the service's state such as changes in a user's
 car battery level to be relayed to the user.
\end_layout

\begin_layout Standard
Due to the architecture of delivery and display when pushed over the internet,
 notification systems are usually part of the mobile operating system such
 as Firebase Cloud Messaging for Android and Apple Push Notification Service
 for iOS.
 Using Firebase Cloud Messaging messages can be sent to individual devices
 or groups of devices, the former being identified using a device specific
 key.
\end_layout

\begin_layout Subsection
Cloud Pub/Sub
\end_layout

\begin_layout Standard
Within a cloud system, the ability to orchestrate different aspects of the
 architecture can be facilitated by sending messages between services.
 This allows asynchronous updates and the spawning of tasks while maintaining
 independence of different parts of the architecture.
 A broad way to do this is by creating a communication channel within which
 messages can be published and subscribed to.
 Cloud Pub/Sub is a GCP service facilitating this form of communication.
 While it has many applications it is particularly useful for long running
 tasks triggered by HTTP requests or for background tasks within a service.
\end_layout

\begin_layout Standard
In order to fully utilise a serverless architecture as described above,
 FaaS Cloud Functions can be configured as subscribers to such messages,
 increasing the speed with which messages can be processed.
\end_layout

\begin_layout Subsection
Scheduling
\end_layout

\begin_layout Standard
When operating a system of larger scale, typically there will be tasks required
 to run repeatedly at predefined time intervals.
 Cloud Scheduler is a service within the Google Cloud Platform taking inspiratio
n from the Unix tool, Cron, allowing commands to be run in the background
 at flexibly defined times.
 
\begin_inset Flex TODO Note (Margin)
status open

\begin_layout Plain Layout
changes in a users car charge level
\end_layout

\end_inset

Cloud Scheduler uses the same string format defining time schedules and
 has many different forms of triggers in including Google App Engine URL
 endpoints and publishing messages to Pub/Sub message channels.
 
\end_layout

\begin_layout Subsection
Final Infrastructure
\end_layout

\begin_layout Standard
Looking to figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:gcp-services"
plural "false"
caps "false"
noprefix "false"

\end_inset

 Firestore was chosen as the data storage element of the final architecture.
 Although a propriety library must be used to interface with the database
 the library does have many benefits such as automatically authenticating
 database actions when code is running on deployed GCP services.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename cloud-structure.png
	lyxscale 30
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Architecture of Google Cloud Platform services
\begin_inset CommandInset label
LatexCommand label
name "fig:gcp-services"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Google App Engine was used to host the Flask application in the standard
 environment which proves to be more than suitable for these requirements.
 This GAE applications provides the public web host name to interface with
 the mobile application and charging unit.
 Cloud Scheduler is used to run utility tasks for the service at regular
 intervals, during development two were defined.
 Each task is encapsulated withing a serverless Cloud Function which is
 triggered by subscribing to separate Cloud Pub/Sub queues.
 Cloud Scheduler can then publish messages to these queues.
\end_layout

\begin_layout Standard
The access token refresh task is part of the authentication workflow
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Authentication"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 The confidential keys used to authenticate with the API should be refreshed
 periodically to reduce the value of any leaked keys, this function performs
 that refresh action.
\end_layout

\begin_layout Standard
The reset queue tasks performs actions related to the semantics of the service.
 In the context of a workplace, the queue of users waiting for charging
 sessions should not necessarily roll over to the next day.
 Electric vehicle owners will typically charge their cars overnight leaving
 charging at work as a top up for the return commute.
 As a result, if a user is not able to receive a session that day, it does
 not necessarily mean they would still want an available session the next
 day.
 To allow this, locations can be configured to have the queue of users reset
 at midnight.
\end_layout

\begin_layout Standard
Each of the compute services being used, namely the GAE application and
 the serverless functions can be configured to use the centralised logging
 provided by GCP allowing intuitive log review.
\end_layout

\begin_layout Standard
Final the Firebase SDK is used in order to deliver mobile notifications
 to users.
\end_layout

\begin_layout Section
Data Model
\end_layout

\begin_layout Standard
In designing the data model for this project objects were defined for users
 and the charging structure, a UML diagram for the architecture can be seen
 in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:class-diagram"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename class diagram.png
	lyxscale 30
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Class diagram for data model
\begin_inset CommandInset label
LatexCommand label
name "fig:class-diagram"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
User
\end_layout

\begin_layout Standard
Users have associated usernames and passwords for identification and authenticat
ion.
 Usernames are the primary key differentiating objects and are case insensitive.
 Passwords are salted and hashed using the Werkzeug security functionality,
 for more information see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Passwords"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
Defining user types allowed the implementation of access controls between
 different use cases.
 End-users are classed as 'user' and have limited access to much of the
 resource types while 'admin' accounts are able to make every types of request,
 naturally this set of users would be heavily restricted.
 Service accounts are used by the charging units in order to make changes
 on behalf of the system.
 This includes changing the state of the charging structure throughout the
 life cycle of a charging session, end-users cannot make any changes of
 this sort.
\end_layout

\begin_layout Standard
The state of the user is defined by the life-cycle of a charging session
 as described in the associated enumerated type.
 Using Python properties, specific state changes for a user have associated
 actions, this is where mobile notifications are triggered in order to inform
 the user of changes in the charging state.
\end_layout

\begin_layout Standard
Users have an access token field and associated last updated time in order
 to secure the HTTP API, the authentication methods used are covered in
 section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Authentication"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
The score and it's associated time of last update are used by the queue
 system in order to determine priorities when selecting the next users for
 a session slot.
 The score is a function of time since it's last update and the users actions
 in that time using update_score(), the score algorithm is covered in section
 
\color red
[SECTION WHERE JACK TALKS ABOUT ALGORITHM]
\color inherit
.
\end_layout

\begin_layout Standard
Check_password() takes a clear-text password string as input and returns
 a boolean value determining whether it is the same as the stored password.
 This works by salting and hashing the query password in the same fashion
 as the initial password was when supplied by the user.
 The hashes are compared for equality which also indicates that the two
 have the same clear-text values.
\end_layout

\begin_layout Subsection
Charging Structure
\end_layout

\begin_layout Standard
The layout for charging architecture defines two object modelling physical
 structure and a session object.
 A Location defines a physical location at which are found charging stations.
 An office building with electric vehicle parking spaces would be a Location
 as would be a multi-storey car park.
 Functionally it is any group of charging spots.
\end_layout

\begin_layout Standard
A Charger is an individual charging station which will have an associated
 charging unit to relay session information.
 
\end_layout

\begin_layout Standard
A Session defines a discrete charging window completed by a user.
 It begins when the queue starts a session for a user who is informed as
 such.
 The user begins charging their car and upon completion is notified that
 they can remove their car.
 When a user unplugs the car the session ends and ticks the location's queue
 to select the next user.
\end_layout

\begin_layout Subsubsection
Location
\end_layout

\begin_layout Standard
A Location has a location_id to act as the primary key, they are case insensitiv
e.
 A location has a list of contained chargers and a list of users representing
 the queue waiting to charge.
 The tick_queue() function updates the score for each user in the queue
 and selects the lowest scoring to receive the next session if available.
 The queue is ticked both when a user is added to the queue and when a session
 ends to ensure the time is used effectively.
\end_layout

\begin_layout Subsubsection
Charger
\end_layout

\begin_layout Standard
A Charger's associated charger_id differentiates chargers of a location,
 they are unique to that location's namespace.
 The active session field is for the integer session_id of the currently
 running session if one is available.
 A null value indicates no session is running.
 The state field functions similarly to the same for the User object and
 defines the charger's position within the life cycle of a session.
\end_layout

\begin_layout Subsubsection
Session
\end_layout

\begin_layout Standard
Sessions are retained after their end for logging purposes, as such integer
 session IDs were selected in order to allow easier retrieval of new IDs.
 To do so the maximum value of all available IDs is incremented.
 Similarly to the charger key, session IDs are unique within their charger's
 namespace, this allows a single session to be identified by a fully qualified
 ID, separated by colons for example,
\end_layout

\begin_layout Quote
location1:charger1:5
\end_layout

\begin_layout Standard
Due to the use of IDs in request URLs and the fully qualified ID, colons,
 spaces and forward slashes are illegal characters for all three IDs.
 Sessions have date-time objects for both their start and end time and a
 reference to the User object who owns the session.
\end_layout

\begin_layout Section
Flask Server
\end_layout

\begin_layout Standard
Flask
\begin_inset CommandInset citation
LatexCommand cite
key "flask"
literal "false"

\end_inset

 is a lean Python web framework that provides flexibility and extensibility
 for web server development.
 The framework is used by instantiating a Flask application and registering
 routes with the app object.
\end_layout

\begin_layout Standard
Routes are registered using a function decorator provided by the application
 defining that method with a URL string pattern to match requests.
 The return value of the method is passed back to the HTTP requester as
 the response.
 This decorator takes both the intended route string pattern and the available
 HTTP methods as parameters.
\end_layout

\begin_layout Subsection
RESTful Services
\end_layout

\begin_layout Standard
When designing a web server an approach taking in to account REST architecture.
 REST or Representational State Transfer is a structure and ethos for designing
 web services.
 Each URL is treated as an identifier for a resource it describes.
 Making requests with different HTTP methods at this URL represents different
 actions to be taken on the object that URL identifies.
 The most common methods are GET, POST, PUT and DELETE.
\end_layout

\begin_layout Standard
GET is typically used as a read only method who's result is a text serialization
 of the object.
\end_layout

\begin_layout Standard
The POST method is used to create an object while PUT is used to replace
 the object.
 For this API PUT is used to replace individual fields of some objects making
 the definition of PUT closer to update.
\end_layout

\begin_layout Standard
DELETE is for deleting the object the URL denotes.
\end_layout

\begin_layout Standard
The aim of a RESTful web service is to make interacting with APIs consistent
 and intuitive both as a whole and when comparing different APIs.
 It is similar to a design pattern.
\end_layout

\begin_layout Standard
A diagram laying out the structure of the API URL routes can be seen in
 figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:api-route-map"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Subsection
Blueprints
\end_layout

\begin_layout Standard
A useful tool for encapsulating discrete parts of a Flask API that should
 still be part of a single application is to use blueprints.
\end_layout

\begin_layout Standard
Blueprints group a set of routes allowing them to be mounted on a Flask
 application object together.
 Blueprints have routes registered in a similar fashion as the Flask application
, blueprints are then individually hung off of a prefix URL string by the
 application following instantiation.
\end_layout

\begin_layout Standard
Blueprints were used to separate routes for authentication, users and the
 charging structure in order to closely follow the data model, a visualisation
 of the final URL route map can be seen in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:api-route-map"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename api-map.png
	lyxscale 30
	width 50col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Visualisation of API endpoints with example fully qualified route
\begin_inset CommandInset label
LatexCommand label
name "fig:api-route-map"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Security
\end_layout

\begin_layout Standard
When operating a cloud-based commercial service arguably the most important
 aspect of it's design is that of security, breaches increasingly occur
 in large public companies allowing unauthorized access to customer's private
 information.
 
\end_layout

\begin_layout Standard
Fortunately, using a serverless architecture abstracts away much of the
 required boilerplate security administration such as managing complex firewall
 setups and intrusion detection and prevention systems (IDS/IPS), instead
 much of this low-level security is provided by the infrastructure itself.
\end_layout

\begin_layout Standard
The three main areas of this service requiring considerations from a security
 perspective are those of access controls, password handling and authentication.
 Access controls have been discussed above in the data model and layout
 of the HTTP API, it involves considering which users should be able to
 conduct what actions and what the implications of such access are.
 For example ensuring that only system owned accounts, admin accounts and
 the user who owns a session can manipulate it.
\end_layout

\begin_layout Subsection
Passwords
\begin_inset CommandInset label
LatexCommand label
name "subsec:Passwords"

\end_inset


\end_layout

\begin_layout Standard
Passwords should never be stored at rest in the cleartext form they are
 provided by users as any breaches of the database will expose sensitive
 user information.
 The impact of such a breach would not only cover this service but could
 prove devastating for users who use the same password across websites (however
 unadvisable that is), this proves to be valuable attack vector for bad
 actors.
\end_layout

\begin_layout Standard
To secure passwords they should undergo obfuscation processes such as salting
 and hashing.
 Hashing is a one-way function that takes a variable length string and produces
 a reproducible fixed length output, the same input string always provides
 the same output string.
 Importantly for password storage is the one way characteristic of the function,
 this means the hashed password cannot be inversely 
\begin_inset Quotes eld
\end_inset

un-hashed
\begin_inset Quotes erd
\end_inset

 back into the clear text string, even with knowledge as to what type of
 hashing was used.
 Cracking hashed passwords must instead be done with large tables of cleartext
 passwords and the associated precomputed hashes, this is known as a rainbow
 table attack.
 In order to protect against brute force attacks of this fashion, salts
 are additionally used.
 A salt is a random string of data that is appended to the user password
 before hashing and then stored with it.
 This reduces the effectiveness of a rainbow table attack as rainbow tables
 cannot practically be pre-calculated for input passwords when mangled by
 a random string in this way.
 For this implementation passwords are salted using a 8 character long salt
 before being hashed using the pbkdf2:sha256 algorithm.
\end_layout

\begin_layout Subsection
Authentication
\begin_inset CommandInset label
LatexCommand label
name "sec:Authentication"

\end_inset


\end_layout

\begin_layout Standard
Authentication is a crucial concern when designing web services.
 Access controls and other security measures are important facets of a system
 however they are useless if weak authentication allows them to be circumvented.
 There are many ways to secure a HTTP API that range in security and complexity,
 finding a balance for the context of the service is important.
\end_layout

\begin_layout Standard
Most methods of authentication eventually authenticate each request using
 a HTTP header with the 
\begin_inset Quotes eld
\end_inset

Authorization
\begin_inset Quotes erd
\end_inset

 key of key-value pairs.
 The value of this header prescribes which method is being used.
\end_layout

\begin_layout Subsubsection
Basic Auth
\end_layout

\begin_layout Standard
One of the most basic methods for authenticating with a HTTP is named as
 such, basic access authentication.
 Basic auth sends the username and password for a user within the authorization
 header in the following format,
\end_layout

\begin_layout Quote
Basic 
\emph on
base64_encode(<username>:<password>)
\end_layout

\begin_layout Standard
Base64 encoding is a binary-to-text encoding method and is not a form of
 encryption or hashing, any agent with the content of the request can trivially
 get access to the cleartext user credentials.
 
\end_layout

\begin_layout Standard
When ensuring, as this service does, that all requests of the API are encrypted
 using TLS, these credentials are secure in transit, however this is not
 the only attack surface which should be protected.
 It also requires the requesting agent to have access to the user's cleartext
 password for inclusion with each request.
 There is inherent risk if each HTTP request includes the unencrypted user
 password and ideally it should occur as little as possible.
 Basic authentication was used during the beta development but eventually
 a more secure method was used for release.
\end_layout

\begin_layout Subsubsection
Bearer Token
\end_layout

\begin_layout Standard
A bearer token delegates the authentication authority from the user credentials
 themselves to a separate piece of secret information.
 In doing so, the need to repeatably share user passwords or the derivatives
 of is removed.
 This additional piece of information is a string of characters typically
 referred to as a key or token, it is provided with each request in the
 authorization header in the form
\end_layout

\begin_layout Quote
Bearer 
\emph on
<token>
\emph default
 
\end_layout

\begin_layout Standard
Bearer tokens in one form or another are the most common form of authorisation
 and authentication for web based APIs with standards such as OAuth (2.0)
 and JSON web tokens (JWT) being well regarded technologies in this space.
 OAuth describes an architecture for API authorization however while being
 a proven structure, the system is fairly complex and has an emphasis on
 allowing third party services delegated access to user information, something
 that wouldn't be required for a service that expects only first party access.
 OAuth is also first and foremost an authorization protocol with use for
 authentication requiring extra steps that take it out of scope for this
 application.
\end_layout

\begin_layout Standard
This service uses a simpler implementation of bearer tokens with each user
 having a unique and randomly generated key stored with their user information.
 Tokens for accounts representing physical people are refreshed on a weekly
 basis, in doing so any compromised key has it's value reduced as a result
 of it's limited life time.
 Keys are not rotated for service accounts as the charging units are expected
 to run without user interaction.
 While users can log back into the app when their token expires, having
 charger unit keys expire in this way would require a workflow to supply
 new keys.
\end_layout

\begin_layout Standard
A more advanced system for refreshing charging unit keys could be based
 on a chain of public key certificates similar to the way that web servers
 and websites prove their identity when using TLS.
 The service could keep control of a root certificate that is used to sign
 further certificates.
 Each charger unit would be entrusted with it's own derivative certificate
 used to sign requests for new tokens.
 This would allow service account tokens to be refreshed as they now have
 a trusted mechanism to retrieve new tokens.
 Charger certificates deemed to be compromised could be revoked requiring
 a unit's certificate to be reset and regenerated.
 This could be done using a physical key such as a USB stick containing
 it's own derivative certificate.
\end_layout

\begin_layout Section
Pricing
\end_layout

\begin_layout Standard
An important aspect of using a third-party hosting platform for all the
 required services is the prices for each service, both currently and when
 anticipating future growth.
 When looking back to figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:gcp-services"
plural "false"
caps "false"
noprefix "false"

\end_inset

 each of the listed services have free tiers and prices following these
 quotas.
 Using estimations of possible system loads and the Google Cloud Platform
 pricing calculator
\begin_inset CommandInset citation
LatexCommand cite
key "gcp-pricing"
literal "false"

\end_inset

 an estimation of running costs can be obtained.
\end_layout

\begin_layout Standard
Firestore database allows 1GB of storage for free, a limit that with the
 scope of service required here would not be easily reached.
 It also allows 50,000 reads, 20,000 writes and 20,000 deletes a day.
\end_layout

\begin_layout Standard
The serverless Cloud Functions allow 2 million invocations a month for free
 with 400,000 GB-seconds memory, 200,000 GHz-seconds of compute time.
 Being used as a utility function for updating user access tokens means
 that these quotas would likely not be reached.
\end_layout

\begin_layout Standard
The service that is most likely to be used beyond it's free quotas is that
 of the App Engine.
 The App Engine provides 28 instance hours a day, while the service would
 not likely be used during the night busy times of day could see more simultaneo
us traffic to the service and require more running instances.
\end_layout

\begin_layout Part
Discussion and Conclusions
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "references"
options "bibtotoc"

\end_inset


\end_layout

\end_body
\end_document
